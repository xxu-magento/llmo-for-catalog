compare_catalog_vs_webpage_task:
  description: >
    INPUTS:
    - pdp_url (string): {pdp_url}

    TASK:
    Perform a two-source comparison for the PDP URL, using the webpage as "scrape-visible truth"
    and the Commerce backend as "authoritative catalog truth".

    Steps (must follow in order):
    1) Call tool `commerce_pdp_scraper` with {"url": pdp_url}.
       - Parse the tool output as JSON.
       - Extract `normalized_sku`.
       - Treat this output as the full set of data that is available from the PDP for scraping.
    2) Call tool `commerce_product_data_by_sku` with {"sku": normalized_sku}.
       - Parse the tool output as JSON.
       - Treat this output as the full set of data available for the SKU in the Commerce catalog backend,
         including (when present):
           - all available product attributes (specs, material, dimensions, certifications, etc.)
           - category placement/path
           - product variants
           - price range based on variants/configurations
    3) Compare fields across the two sources:
       - Webpage output is LIMITED to what is visible/embedded on the PDP.
       - Backend output is COMPREHENSIVE and the SOURCE OF TRUTH when conflicts exist.
    4) Produce a structured comparison report:
       - matches (same/compatible values)
       - mismatches (conflicts; backend is source of truth)
       - missing_on_webpage (fields present in backend but absent/weak on webpage)
       - missing_in_backend (fields present on webpage but absent in backend; flag as potential catalog gap)
    5) IMPORTANT: Include both raw tool outputs (parsed JSON) in the final comparison output:
       - raw_sources.webpage
       - raw_sources.backend
       This is required so downstream agents can propose enrichments without re-calling tools.

    OUTPUT RULES (mandatory):
    - Output MUST be valid JSON.
    - Output MUST contain ONLY the keys specified in EXPECTED_OUTPUT.
    - Do NOT wrap output in markdown or code fences.

  expected_output: >
    {
      "pdp_url": "string",
      "sku": "string",
      "raw_sources": {
        "webpage": "object",
        "backend": "object"
      },
      "webpage_product": "object",
      "commerce_product": "object",
      "matches": [
        {
          "field": "string",
          "webpage_value": "any",
          "backend_value": "any",
          "notes": "string"
        }
      ],
      "mismatches": [
        {
          "field": "string",
          "webpage_value": "any",
          "backend_value": "any",
          "impact": "string"
        }
      ],
      "missing_on_webpage": [
        {
          "field": "string",
          "backend_value": "any",
          "why_important": "string"
        }
      ],
      "missing_in_backend": [
        {
          "field": "string",
          "webpage_value": "any",
          "why_important": "string"
        }
      ],
      "summary": {
        "top_issues": ["string"],
        "recommended_focus": ["string"]
      }
    }
  agent: catalog_comparison_agent


product_page_enrichment_task:
  description: >
    INPUTS:
    - JSON output of `compare_catalog_vs_webpage_task` in context.

    REQUIRED INPUT CONTENT (must exist inside compare task output):
    - raw_sources.webpage: parsed output of `commerce_pdp_scraper` (including `raw`, `seo`, `pdp`, etc. if present)
    - raw_sources.backend: parsed output of `commerce_product_data_by_sku` (including `raw` and variants/priceRange if present)
    - missing_on_webpage / mismatches lists for guidance

    TASK:
    Produce ONE consolidated enrichment proposal to apply to the PDP webpage ONLY,
    based on delta information that exists in Commerce backend but is missing/weak on the PDP.

    HARD CONSTRAINTS (deterministic):
    - Webpage-only changes. Do NOT propose any backend catalog edits.
    - Do NOT invent facts. Any facts.* or factual pdp.* additions must be supported by backend_value
      in raw_sources.backend OR explicitly indicated by compare output.
    - Do NOT output intent.* fields (handled by product_catalog_enrichment_task).
    - Output MUST be valid JSON.
    - Output MUST have EXACTLY two top-level keys:
      1) "suggested_changes"
      2) "explanations"
    - Do NOT include any other top-level keys.
    - Do NOT wrap output in markdown or code fences.

    OUTPUT CONTENT RULES:
    - suggested_changes must include only webpage-applied fields in these namespaces:

      FACTS / PDP FACT SURFACING (backend-supported only):
        - facts.attributes.<name>                 (any JSON value)
        - facts.variants.summary                  (array of strings; high-level variant characteristics)
        - facts.facets.category_path              (array of strings)
        - pdp.feature_bullets                     (array of strings; factual bullets only)
        - pdp.description_plain                   (string; factual additions only)
    
    - explanations must contain the SAME keys as suggested_changes.
      Each key maps to an object with:
        { why, source, evidence, implementation_notes }

    SOURCE RULES:
    - For facts.* and factual pdp.*: source MUST be "commerce_backend"
    
    EVIDENCE RULES:
    - evidence.webpage_value: read from raw_sources.webpage (or null)
    - evidence.backend_value: read from raw_sources.backend (required, not null)

  expected_output: >
    {
      "suggested_changes": {
        "facts.attributes.<name>": "any",
        "facts.variants.summary": ["string"],
        "facts.facets.category_path": ["string"],
        "pdp.feature_bullets": ["string"],
        "pdp.description_plain": "string"
      },
      "explanations": {
        "facts.attributes.<name>": {
          "why": "string",
          "source": "commerce_backend",
          "evidence": {
            "webpage_value": "any or null",
            "backend_value": "any"
          },
          "implementation_notes": "string"
        },
        "facts.variants.summary": {
          "why": "string",
          "source": "commerce_backend",
          "evidence": {
            "webpage_value": "any or null",
            "backend_value": "any"
          },
          "implementation_notes": "string"
        },
        "facts.facets.category_path": {
          "why": "string",
          "source": "commerce_backend",
          "evidence": {
            "webpage_value": "any or null",
            "backend_value": "any"
          },
          "implementation_notes": "string"
        },
        "pdp.feature_bullets": {
          "why": "string",
          "source": "commerce_backend",
          "evidence": {
            "webpage_value": "any or null",
            "backend_value": "any"
          },
          "implementation_notes": "string"
        },
        "pdp.description_plain": {
          "why": "string",
          "source": "commerce_backend",
          "evidence": {
            "webpage_value": "any or null",
            "backend_value": "any"
          },
          "implementation_notes": "string"
      }
      }
    }
  agent: product_page_enrichment_agent


product_catalog_enrichment_task:
  description: >
    INPUTS:
    - JSON output of `compare_catalog_vs_webpage_task` in context.

    REQUIRED INPUT CONTENT (must exist inside compare task output):
    - raw_sources.webpage: parsed output of `commerce_pdp_scraper` (use for current SEO tags / page language / tone)
    - raw_sources.backend: parsed output of `commerce_product_data_by_sku` (use for factual consistency)
    - webpage_product fields (if present) such as scraped seo and visible content
    - missing_on_webpage / mismatches lists for guidance

    TASK:
    Propose Commerce catalog backend enrichment in TWO areas:
      (A) Catalog-managed SEO/content fields:
          - catalog.seo.title_tag
          - catalog.seo.meta_description
          - catalog.seo.h1
          - optional catalog.pdp.title
      (B) Catalog-stored shopper intent fields:
          - intent.use_context
          - intent.target_personas

    HARD CONSTRAINTS:
    - These changes are intended to be applied to the Commerce catalog backend (not direct HTML edits).
    - Output MUST be valid JSON.
    - Output MUST have EXACTLY two top-level keys:
      1) "suggested_changes"
      2) "explanations"
    - Do NOT include any other top-level keys.
    - Do NOT wrap output in markdown or code fences.
    - Match the language of the page content.
    - Avoid keyword stuffing; keep phrasing natural and human-written.
    - Keep title/meta/h1 distinct (not near-duplicates).
    - Preserve detected title formatting pattern if present (brand prefix/suffix).
    - Do not invent facts or claims (materials/certifications) unless present in backend data.

    LENGTH RULES (mandatory; do NOT mention in rationales):
    - catalog.seo.title_tag: 30-65 chars
    - catalog.seo.h1: 10-70 chars
    - catalog.seo.meta_description: 100-160 chars

    OUTPUT CONTENT RULES:
    - suggested_changes keys allowed:
      - catalog.seo.title_tag
      - catalog.seo.meta_description
      - catalog.seo.h1
      - catalog.pdp.title (optional)
      - intent.use_context
      - intent.target_personas

    - explanations must contain the SAME keys as suggested_changes.
      Each key maps to { why, source, evidence, implementation_notes }.

    SOURCE RULES:
    - For catalog.* SEO/content: source MUST be "webpage_context"
    - For intent.*: source MUST be "inferred"

    EVIDENCE RULES:
    - evidence.webpage_value: read from raw_sources.webpage (or null)
    - evidence.backend_value: read from raw_sources.backend (or null, unless needed to justify factual claims)

  expected_output: >
    {
      "suggested_changes": {
        "catalog.seo.title_tag": "string",
        "catalog.seo.meta_description": "string",
        "catalog.seo.h1": "string",
        "catalog.pdp.title": "string",
        "intent.use_context": ["string"],
        "intent.target_personas": ["string"]
      },
      "explanations": {
        "catalog.seo.title_tag": {
          "why": "string",
          "source": "webpage_context",
          "evidence": {
            "webpage_value": "any or null",
            "backend_value": "any or null"
          },
          "implementation_notes": "string"
        },
        "catalog.seo.meta_description": {
          "why": "string",
          "source": "webpage_context",
          "evidence": {
            "webpage_value": "any or null",
            "backend_value": "any or null"
          },
          "implementation_notes": "string"
        },
        "catalog.seo.h1": {
          "why": "string",
          "source": "webpage_context",
          "evidence": {
            "webpage_value": "any or null",
            "backend_value": "any or null"
          },
          "implementation_notes": "string"
        },
        "catalog.pdp.title": {
          "why": "string",
          "source": "webpage_context",
          "evidence": {
            "webpage_value": "any or null",
            "backend_value": "any or null"
          },
          "implementation_notes": "string"
        },
        "intent.use_context": {
          "why": "string",
          "source": "inferred",
          "evidence": {
            "webpage_value": "any or null",
            "backend_value": "any or null"
          },
          "implementation_notes": "string"
        },
        "intent.target_personas": {
          "why": "string",
          "source": "inferred",
          "evidence": {
            "webpage_value": "any or null",
            "backend_value": "any or null"
          },
          "implementation_notes": "string"
        }
      }
    }
  agent: product_catalog_enrichment_agent


synthesize_final_change_plan_task:
  description: >
    INPUTS:
    - JSON output of `compare_catalog_vs_webpage_task`
    - JSON output of `product_page_enrichment_task`
    - JSON output of `product_catalog_enrichment_task`

    REQUIRED INPUT CONTENT:
    - compare output includes raw_sources.webpage and raw_sources.backend
    - enrichment outputs include suggested_changes and explanations

    TASK:
    Merge and reconcile suggested changes into one final plan.

    MERGE / CONFLICT RESOLUTION RULES (deterministic):
    1) For keys starting with "catalog.": prefer product_catalog_enrichment_task.
    2) For keys starting with "intent.": prefer product_catalog_enrichment_task.
    3) For keys starting with "facts." or "pdp.": prefer product_page_enrichment_task.
    4) If the same key appears in multiple sources, pick the preferred source above and record the other candidate(s)
       in conflicts_resolved.
    5) Do not include any fields that contradict backend facts.

    DE-DUPLICATION RULE (agnostic to prior plans):
    - For each proposed field, compare the proposed value to the CURRENT value found in:
      - raw_sources.webpage (if the field exists there), and
      - raw_sources.backend (if the field exists there)
    - If the proposed value is identical OR a near-duplicate of an existing current value (same meaning / trivial rephrase),
      then IGNORE the new proposed change and record it in conflicts_resolved with rationale "ignored_duplicate_or_near_duplicate".
      (Example: proposed "Happy Fun Ball!" vs existing "Joyful Fun Ball!" should be considered near-duplicates.)
    - Near-duplicate detection should be conservative: ignore only when very likely equivalent to avoid missing real improvements.

    OUTPUT RULES:
    - Output MUST be valid JSON.
    - Output MUST contain ONLY the keys specified in EXPECTED_OUTPUT.
    - Do NOT wrap output in markdown or code fences.

    VALIDATION RULE:
    - Set validation.schema_ok=true only if your output matches EXPECTED_OUTPUT exactly:
      top-level keys and required nested keys exist with correct types.
  
  expected_output: >
    {
      "final_suggested_changes": {
        "any_field_key": "any"
      },
      "final_explanations": {
        "any_field_key": {
          "why": "string",
          "sources": ["string"],
          "evidence": {
            "webpage_value": "any or null",
            "backend_value": "any or null"
          },
          "implementation_notes": "string"
        }
      },
      "conflicts_resolved": [
        {
          "field": "string",
          "candidates": [
            {"from": "string", "value": "any"}
          ],
          "chosen": {"from": "string", "value": "any"},
          "rationale": "string"
        }
      ],
      "validation": {
        "schema_ok": true,
        "notes": "string"
      }
    }
  agent: change_synthesizer_agent
